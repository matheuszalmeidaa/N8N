"""
================================================================================
CONSULTA API FINTECH - CONFIGURA√á√ÉO E EXTRA√á√ÉO DE DADOS
================================================================================
Vers√£o corrigida - Extra√ß√£o de hist√≥ricos funcionando
"""

import requests
import pandas as pd
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import time
import json
from sqlalchemy import create_engine, text
from tqdm import tqdm
import warnings
warnings.filterwarnings('ignore')


# ============================================================================
# SE√á√ÉO DE CONFIGURA√á√ÉO - CUSTOMIZE AQUI
# ============================================================================

class Config:
    """Configura√ß√µes principais do sistema"""
    
    # === AUTENTICA√á√ÉO API ===
    API_BASE_URL = "https://api.anossafintech.com.br"
    CPF_LOGIN = "05134108560"
    PROMOT_ID = "1"
    PASSWORD = "Alcif@2026"
    
    # ========================================================================
    # MODOS DE FILTRO DE PER√çODO (escolha apenas UM m√©todo)
    # ========================================================================
    
    # MODO 1: DIA ESPEC√çFICO üìÖ
    # Consulta apenas um dia espec√≠fico (ignora outros filtros de data)
    USAR_DIA_ESPECIFICO = False
    DIA_ESPECIFICO = "2025-11-28"      # Formato: "YYYY-MM-DD"
    
    # MODO 2: PER√çODO CUSTOMIZADO üìÜ
    # Define data_inicio e data_fim manualmente
    USAR_PERIODO_CUSTOMIZADO = False
    PERIODO_INICIO = "2025-11-01"      # Formato: "YYYY-MM-DD"
    PERIODO_FIM = "2025-11-05"         # Formato: "YYYY-MM-DD"
    
    # MODO 3: √öLTIMOS N DIAS üïê
    # Consulta os √∫ltimos X dias (ex: √∫ltimos 7 dias)
    USAR_ULTIMOS_DIAS = False
    QUANTIDADE_ULTIMOS_DIAS = 7        # N√∫mero de dias para tr√°s
    
    # MODO 4: M√äS COMPLETO üìä
    # Consulta um m√™s inteiro automaticamente
    USAR_MES_COMPLETO = False
    MES_COMPLETO = "11/2025"           # Formato: "MM/YYYY"
    
    # MODO 5: PADR√ÉO (PER√çODO GERAL) üóìÔ∏è
    # Usa data_inicio_geral at√© ontem (ou data_fim_manual)
    DATA_INICIO_GERAL = "2025-03-18"   # Data inicial da extra√ß√£o
    USAR_DATA_FIM_ONTEM = True         # True = usa ontem como limite
    DATA_FIM_MANUAL = None             # Use se USAR_DATA_FIM_ONTEM = False
    
    # ========================================================================
    
    # === FILTROS ADICIONAIS ===
    FILTRAR_POR_MES = True             # Ativar filtro de m√™s espec√≠fico
    MES_ANO_DESEJADO = "11/2025"       # Formato: "MM/YYYY"
    
    # === CONFIGURA√á√ÉO DE LOTES ===
    DIAS_POR_PERIODO = 1               # Dist√¢ncia entre data_inicio de cada per√≠odo
    PERIODOS_POR_LOTE = 5              # Quantos per√≠odos em cada lote
    FILTRAR_POR_LOTE = True            # Ativar filtro de lote espec√≠fico
    LOTE_DESEJADO = 1                  # Qual lote processar
    
    # === ORDEM DE PROCESSAMENTO ===
    ORDEM_DATAS = "decrescente"        # "crescente" ou "decrescente"
    
    # === DELAYS E PERFORMANCE ===
    DELAY_ENTRE_REQUESTS = 0.2         # Segundos entre requisi√ß√µes
    TIMEOUT_REQUEST = 30               # Timeout por requisi√ß√£o
    MOSTRAR_PROGRESSO_OPERACOES = True # Mostra barra de progresso
    
    # === BANCO DE DADOS ===
    USAR_BANCO = False                 # Ativar inser√ß√£o em banco
    DB_CONNECTION_STRING = "postgresql://usuario:senha@localhost:5432/database"
    TABELA_DESTINO = "fintech_operacoes"
    LIMPAR_TABELA_ANTES = True         # Limpar dados antes de inserir
    
    # === EXPORTA√á√ÉO ===
    EXPORTAR_EXCEL = True              # Gerar arquivo Excel
    CAMINHO_EXCEL = "./exports/"       # Pasta para exports
    NOME_ARQUIVO_CUSTOMIZADO = None    # Ex: "Relatorio_Novembro.xlsx" (None = auto)
    
    # === FILTROS DE DADOS ===
    # Filtrar apenas opera√ß√µes com determinado status
    FILTRAR_POR_STATUS = False
    STATUS_DESEJADOS = ["Rascunho", "Aprovado"]  # Lista de status permitidos
    
    # Filtrar apenas opera√ß√µes de determinados clientes
    FILTRAR_POR_CPF = False
    CPFS_PERMITIDOS = ["12345678900", "98765432100"]  # Lista de CPFs
    
    # Filtrar por valor m√≠nimo
    FILTRAR_POR_VALOR_MINIMO = False
    VALOR_MINIMO = 10000               # Apenas opera√ß√µes >= este valor
    
    # === LOGS E DEBUG ===
    MOSTRAR_CONFIG_INICIAL = True      # Mostra configura√ß√µes no in√≠cio
    MOSTRAR_LOGS_DETALHADOS = False    # Logs verbosos da API
    MOSTRAR_PROGRESSO_BARRA = True     # Barra de progresso visual
    SALVAR_JSON_RAW = False            # Salvar respostas JSON brutas
    DEBUG_HISTORICOS = True            # Debug espec√≠fico de hist√≥ricos
    EXIBIR_AMOSTRA_DADOS = True        # Mostra amostra dos dados no final
    QUANTIDADE_AMOSTRAS = 3            # Quantos registros mostrar na amostra
    SALVAR_LOG_ERROS = True            # Salva arquivo com erros detalhados
    CAMINHO_LOG_ERROS = "./logs/"      # Pasta para logs de erro
    DEBUG_PRIMEIROS_ERROS = 5          # Mostra detalhes dos primeiros N erros
    
    # === RELAT√ìRIOS E AN√ÅLISES ===
    GERAR_RELATORIO_DETALHADO = True   # Gera relat√≥rio com estat√≠sticas completas
    AGRUPAR_POR_BANCO = True           # Mostra totais por banco
    AGRUPAR_POR_SITUACAO = True        # Mostra totais por situa√ß√£o
    MOSTRAR_VALORES_TOTAIS = True      # Exibe soma de valores
    LISTAR_ERROS_DETALHADOS = True     # Lista opera√ß√µes com erro (se houver)
    
    # === PERFORMANCE E OTIMIZA√á√ÉO ===
    MODO_RAPIDO = False                # Pula valida√ß√µes extras (mais r√°pido)
    LIMITE_OPERACOES = None            # Limita n√∫mero de opera√ß√µes (None = sem limite)
    PROCESSAR_EM_PARALELO = False      # [FUTURO] Processamento paralelo
    
    # === NOTIFICA√á√ïES ===
    ENVIAR_EMAIL_CONCLUSAO = False     # Envia email ao finalizar
    EMAIL_DESTINO = "seu@email.com"    # Email para notifica√ß√µes
    NOTIFICAR_SE_ERRO = True           # Notifica apenas se houver erros
    
    # === RETRY E RESILI√äNCIA ===
    TENTATIVAS_RETRY = 3               # Tentativas em caso de erro na API
    DELAY_RETRY = 1                    # Segundos entre tentativas
    CONTINUAR_APOS_ERRO = True         # Continua mesmo com erros individuais
    MOSTRAR_ERROS_TEMPO_REAL = False   # Mostra erros conforme acontecem (pode poluir tela)


# ============================================================================
# CLASSES PRINCIPAIS
# ============================================================================

class FintechAPI:
    """Gerenciador de chamadas √† API"""
    
    def __init__(self, config: Config):
        self.config = config
        self.token = None
        self.session = requests.Session()
        
    def autenticar(self) -> bool:
        """ETAPA 1: AUTENTICA√á√ÉO"""
        url = f"{self.config.API_BASE_URL}/auth/login"
        
        payload = {
            "cpf": self.config.CPF_LOGIN,
            "promot_id": self.config.PROMOT_ID,
            "password": self.config.PASSWORD
        }
        
        headers = {"Content-Type": "application/json"}
        
        try:
            response = self.session.post(url, json=payload, headers=headers)
            response.raise_for_status()
            
            data = response.json()
            
            self.token = (data.get('token') or 
                         data.get('access_token') or 
                         data.get('auth_token') or
                         data.get('bearer_token'))
            
            if not self.token and 'data' in data:
                self.token = data['data'].get('token')
            if not self.token and 'result' in data:
                self.token = data['result'].get('token')
            
            if self.token:
                self.session.headers.update({
                    'Authorization': f'Bearer {self.token}'
                })
                print("‚úÖ Autentica√ß√£o realizada com sucesso!")
                print(f"   Token: {self.token[:20]}...{self.token[-10:]}\n")
                return True
            else:
                print("‚ùå Token n√£o encontrado na resposta")
                return False
                
        except Exception as e:
            print(f"‚ùå Erro na autentica√ß√£o: {e}")
            return False
    
    def consultar_operacoes(self, data_inicio: str, data_fim: str) -> Optional[List[Dict]]:
        """API 1: LISTA OPERA√á√ïES"""
        url = f"{self.config.API_BASE_URL}/inss/v1/operation"
        
        params = {
            'data_inicio': data_inicio,
            'data_fim': data_fim,
            'por_pagina': 200000
        }
        
        try:
            response = self.session.get(
                url, 
                params=params,
                timeout=self.config.TIMEOUT_REQUEST
            )
            response.raise_for_status()
            
            data = response.json()
            operacoes = data.get('operacoes', [])
            
            return operacoes
            
        except Exception as e:
            print(f"  ‚ùå Erro ao consultar opera√ß√µes: {e}")
            return None
    
    def consultar_detalhes_operacao(self, debt_key: str, credit_operation_key: str = None) -> tuple[Optional[Dict], Optional[str]]:
        """
        API 2: DETALHES DA OPERA√á√ÉO
        Retorna: (dados, mensagem_erro)
        """
        url = f"{self.config.API_BASE_URL}/inss/v1/operation/{debt_key}"
        
        if credit_operation_key and credit_operation_key.strip():
            url += f"?credit_operation_key={credit_operation_key}"
        
        # Sistema de retry
        ultimo_erro = None
        for tentativa in range(self.config.TENTATIVAS_RETRY):
            try:
                response = self.session.get(url, timeout=self.config.TIMEOUT_REQUEST)
                response.raise_for_status()
                return response.json(), None
                
            except requests.exceptions.Timeout as e:
                ultimo_erro = f"Timeout (tentativa {tentativa + 1}/{self.config.TENTATIVAS_RETRY})"
                if tentativa < self.config.TENTATIVAS_RETRY - 1:
                    time.sleep(self.config.DELAY_RETRY)
                    continue
                    
            except requests.exceptions.HTTPError as e:
                ultimo_erro = f"HTTP {response.status_code}: {response.reason}"
                if tentativa < self.config.TENTATIVAS_RETRY - 1 and response.status_code >= 500:
                    time.sleep(self.config.DELAY_RETRY)
                    continue
                break  # N√£o tenta novamente em erros 4xx
                
            except Exception as e:
                ultimo_erro = f"Erro: {str(e)}"
                if tentativa < self.config.TENTATIVAS_RETRY - 1:
                    time.sleep(self.config.DELAY_RETRY)
                    continue
        
        return None, ultimo_erro


class ProcessadorDados:
    """Processa e transforma os dados extra√≠dos"""
    
    @staticmethod
    def gerar_periodos(config: Config) -> pd.DataFrame:
        """
        Gera per√≠odos de consulta baseado nas configura√ß√µes
        Suporta 5 modos diferentes de filtro de per√≠odo
        """
        
        # ====================================================================
        # MODO 1: DIA ESPEC√çFICO üìÖ
        # ====================================================================
        if config.USAR_DIA_ESPECIFICO:
            data_unica = datetime.strptime(config.DIA_ESPECIFICO, "%Y-%m-%d")
            periodos = [{
                'indice': 1,
                'data_inicio': data_unica.strftime("%Y-%m-%d"),
                'data_fim': data_unica.strftime("%Y-%m-%d"),
                'mes_ano': data_unica.strftime("%m/%Y")
            }]
            df = pd.DataFrame(periodos)
            df['lote'] = 1
            print(f"   üéØ Modo: Dia Espec√≠fico ({config.DIA_ESPECIFICO})")
            return df
        
        # ====================================================================
        # MODO 2: PER√çODO CUSTOMIZADO üìÜ
        # ====================================================================
        if config.USAR_PERIODO_CUSTOMIZADO:
            data_inicio = datetime.strptime(config.PERIODO_INICIO, "%Y-%m-%d")
            data_fim = datetime.strptime(config.PERIODO_FIM, "%Y-%m-%d")
            print(f"   üéØ Modo: Per√≠odo Customizado ({config.PERIODO_INICIO} at√© {config.PERIODO_FIM})")
        
        # ====================================================================
        # MODO 3: √öLTIMOS N DIAS üïê
        # ====================================================================
        elif config.USAR_ULTIMOS_DIAS:
            data_fim = datetime.now() - timedelta(days=1)  # Ontem
            data_inicio = data_fim - timedelta(days=config.QUANTIDADE_ULTIMOS_DIAS - 1)
            print(f"   üéØ Modo: √öltimos {config.QUANTIDADE_ULTIMOS_DIAS} Dias")
        
        # ====================================================================
        # MODO 4: M√äS COMPLETO üìä
        # ====================================================================
        elif config.USAR_MES_COMPLETO:
            mes, ano = config.MES_COMPLETO.split('/')
            data_inicio = datetime(int(ano), int(mes), 1)
            # √öltimo dia do m√™s
            if int(mes) == 12:
                data_fim = datetime(int(ano), 12, 31)
            else:
                data_fim = datetime(int(ano), int(mes) + 1, 1) - timedelta(days=1)
            
            # N√£o passa de ontem
            ontem = datetime.now() - timedelta(days=1)
            if data_fim > ontem:
                data_fim = ontem
            
            print(f"   üéØ Modo: M√™s Completo ({config.MES_COMPLETO})")
        
        # ====================================================================
        # MODO 5: PADR√ÉO (PER√çODO GERAL) üóìÔ∏è
        # ====================================================================
        else:
            data_inicio = datetime.strptime(config.DATA_INICIO_GERAL, "%Y-%m-%d")
            
            if config.USAR_DATA_FIM_ONTEM:
                data_fim = datetime.now() - timedelta(days=1)
            else:
                data_fim = datetime.strptime(config.DATA_FIM_MANUAL, "%Y-%m-%d")
            
            print(f"   üéØ Modo: Per√≠odo Geral (desde {config.DATA_INICIO_GERAL})")
        
        # ====================================================================
        # GERA√á√ÉO DOS PER√çODOS
        # ====================================================================
        periodos = []
        cursor = data_inicio
        indice = 1
        
        while cursor <= data_fim:
            inicio_intervalo = cursor
            fim_intervalo = cursor + timedelta(days=config.DIAS_POR_PERIODO - 1)
            
            if fim_intervalo > data_fim:
                fim_intervalo = data_fim
            
            mes_ano = inicio_intervalo.strftime("%m/%Y")
            
            periodos.append({
                'indice': indice,
                'data_inicio': inicio_intervalo.strftime("%Y-%m-%d"),
                'data_fim': fim_intervalo.strftime("%Y-%m-%d"),
                'mes_ano': mes_ano
            })
            
            cursor += timedelta(days=config.DIAS_POR_PERIODO)
            indice += 1
        
        df = pd.DataFrame(periodos)
        
        # Aplica ordena√ß√£o
        if config.ORDEM_DATAS == "decrescente":
            df = df.iloc[::-1].reset_index(drop=True)
            df['indice'] = range(1, len(df) + 1)
        
        # Adiciona n√∫mero do lote
        df['lote'] = ((df.index) // config.PERIODOS_POR_LOTE) + 1
        
        # Aplica filtros adicionais
        if config.FILTRAR_POR_MES and not config.USAR_MES_COMPLETO:
            df = df[df['mes_ano'] == config.MES_ANO_DESEJADO].reset_index(drop=True)
        
        if config.FILTRAR_POR_LOTE:
            df = df[df['lote'] == config.LOTE_DESEJADO].reset_index(drop=True)
        
        return df
    
    @staticmethod
    def formatar_data_completa(data_raw) -> str:
        """Formata data para padr√£o brasileiro completo"""
        if not data_raw:
            return None
        
        try:
            d = datetime.fromisoformat(data_raw.replace('Z', '+00:00'))
            return d.strftime("%d/%m/%Y %H:%M:%S")
        except:
            return None
    
    @staticmethod
    def aplicar_filtros_dados(df: pd.DataFrame, config: Config) -> pd.DataFrame:
        """
        Aplica filtros adicionais nos dados extra√≠dos
        """
        df_original = len(df)
        
        # Filtro por status
        if config.FILTRAR_POR_STATUS and 'historico_status' in df.columns:
            df = df[df['historico_status'].isin(config.STATUS_DESEJADOS)]
            print(f"   üîç Filtro de status aplicado: {len(df)}/{df_original} registros mantidos")
        
        # Filtro por CPF
        if config.FILTRAR_POR_CPF and 'cpf' in df.columns:
            df = df[df['cpf'].isin(config.CPFS_PERMITIDOS)]
            print(f"   üîç Filtro de CPF aplicado: {len(df)}/{df_original} registros mantidos")
        
        # Filtro por valor m√≠nimo
        if config.FILTRAR_POR_VALOR_MINIMO and 'val_liquido' in df.columns:
            df = df[df['val_liquido'] >= config.VALOR_MINIMO]
            print(f"   üîç Filtro de valor m√≠nimo aplicado: {len(df)}/{df_original} registros mantidos")
        
        return df
    
    @staticmethod
    def gerar_relatorio_estatistico(df: pd.DataFrame, config: Config) -> None:
        """
        Gera relat√≥rio estat√≠stico detalhado dos dados extra√≠dos
        """
        if not config.GERAR_RELATORIO_DETALHADO:
            return
        
        print("\n" + "="*80)
        print("üìä RELAT√ìRIO ESTAT√çSTICO DETALHADO")
        print("="*80)
        
        # Totais gerais
        if config.MOSTRAR_VALORES_TOTAIS:
            if 'val_liquido' in df.columns:
                total_liquido = df['val_liquido'].sum()
                media_liquido = df['val_liquido'].mean()
                print(f"\nüí∞ VALORES FINANCEIROS:")
                print(f"   ‚Ä¢ Total l√≠quido: R$ {total_liquido:,.2f}")
                print(f"   ‚Ä¢ M√©dia por opera√ß√£o: R$ {media_liquido:,.2f}")
                print(f"   ‚Ä¢ Maior valor: R$ {df['val_liquido'].max():,.2f}")
                print(f"   ‚Ä¢ Menor valor: R$ {df['val_liquido'].min():,.2f}")
            
            if 'val_emissao' in df.columns:
                total_emissao = df['val_emissao'].sum()
                print(f"   ‚Ä¢ Total de emiss√£o: R$ {total_emissao:,.2f}")
        
        # Agrupamento por banco
        if config.AGRUPAR_POR_BANCO and 'bank_name' in df.columns:
            print(f"\nüè¶ DISTRIBUI√á√ÉO POR BANCO:")
            bancos = df.groupby('bank_name').agg({
                'debt_key': 'count',
                'val_liquido': 'sum' if 'val_liquido' in df.columns else 'count'
            }).sort_values('debt_key', ascending=False)
            
            for banco, row in bancos.head(10).iterrows():
                if 'val_liquido' in df.columns:
                    print(f"   ‚Ä¢ {banco}: {row['debt_key']} ops (R$ {row['val_liquido']:,.2f})")
                else:
                    print(f"   ‚Ä¢ {banco}: {row['debt_key']} ops")
        
        # Agrupamento por situa√ß√£o
        if config.AGRUPAR_POR_SITUACAO and 'dsc_situacao_emprestimo' in df.columns:
            print(f"\nüìã DISTRIBUI√á√ÉO POR SITUA√á√ÉO:")
            situacoes = df['dsc_situacao_emprestimo'].value_counts()
            for situacao, count in situacoes.head(10).items():
                percentual = (count / len(df)) * 100
                print(f"   ‚Ä¢ {situacao}: {count} ({percentual:.1f}%)")
        
        # Distribui√ß√£o por estado
        if 'benefit_state' in df.columns:
            print(f"\nüó∫Ô∏è  TOP 10 ESTADOS:")
            estados = df['benefit_state'].value_counts().head(10)
            for estado, count in estados.items():
                print(f"   ‚Ä¢ {estado}: {count} opera√ß√µes")
        
        # An√°lise de hist√≥ricos
        if 'quantidade_historicos' in df.columns:
            print(f"\nüìú AN√ÅLISE DE HIST√ìRICOS:")
            print(f"   ‚Ä¢ M√©dia de hist√≥ricos por opera√ß√£o: {df['quantidade_historicos'].mean():.1f}")
            print(f"   ‚Ä¢ M√°ximo de hist√≥ricos: {df['quantidade_historicos'].max()}")
            print(f"   ‚Ä¢ Opera√ß√µes com 1 hist√≥rico: {(df['quantidade_historicos'] == 1).sum()}")
            print(f"   ‚Ä¢ Opera√ß√µes com 5+ hist√≥ricos: {(df['quantidade_historicos'] >= 5).sum()}")
        
        print()
        """
        üîß CORRE√á√ÉO PRINCIPAL: Acessa corretamente a estrutura de hist√≥ricos
        
        A API retorna hist√≥ricos em diferentes locais poss√≠veis:
        1. detalhes['operation']['histories']  ‚Üê CORRETO (estrutura do n8n)
        2. detalhes['histories']
        3. Dentro de outros campos aninhados
        """
        
        # Tenta acessar operation primeiro (estrutura correta do n8n)
        operation_data = detalhes.get('operation', {})
        
        # üîç BUSCA HIST√ìRICOS EM TODAS AS LOCALIZA√á√ïES POSS√çVEIS
        histories = None
        
        # Op√ß√£o 1: operation.histories (PRINCIPAL - como no n8n)
        if isinstance(operation_data, dict) and 'histories' in operation_data:
            histories = operation_data.get('histories', [])
            if config.DEBUG_HISTORICOS and histories:
                print(f"      ‚úì Hist√≥ricos encontrados em operation.histories: {len(histories)} registros")
        
        # Op√ß√£o 2: Diretamente em detalhes.histories  
        if not histories and 'histories' in detalhes:
            histories = detalhes.get('histories', [])
            if config.DEBUG_HISTORICOS and histories:
                print(f"      ‚úì Hist√≥ricos encontrados em detalhes.histories: {len(histories)} registros")
        
        # Op√ß√£o 3: Dentro de data.operation.histories
        if not histories and 'data' in detalhes:
            data_obj = detalhes.get('data', {})
            if isinstance(data_obj, dict):
                op_inside = data_obj.get('operation', {})
                if isinstance(op_inside, dict):
                    histories = op_inside.get('histories', [])
                    if config.DEBUG_HISTORICOS and histories:
                        print(f"      ‚úì Hist√≥ricos encontrados em data.operation.histories: {len(histories)} registros")
        
        # Garante que histories √© uma lista
        if not isinstance(histories, list):
            histories = []
        
        # Debug: mostra se n√£o encontrou hist√≥rico
        if config.DEBUG_HISTORICOS and not histories:
            print(f"      ‚ö†Ô∏è  Nenhum hist√≥rico encontrado para debt_key={operacao.get('debt_key')}")
            print(f"      üìã Estrutura da resposta: {list(detalhes.keys())}")
            if 'operation' in detalhes:
                print(f"      üìã Campos em operation: {list(detalhes['operation'].keys())}")
        
        # Se n√£o tem hist√≥rico, retorna lista vazia (n√£o gera registro)
        if not histories:
            return []
        
        # Formata data
        data_formatada = ProcessadorDados.formatar_data_completa(
            operacao.get('dat_emprestimo')
        )
        
        registros = []
        
        for hist in histories:
            registro = {
                # Campos da opera√ß√£o original (API 1)
                'cpf': operacao.get('cpf'),
                'dat_emprestimo_completo': data_formatada,
                'debt_key': operacao.get('debt_key'),
                'credit_operation_key': operacao.get('credit_operation_key'),
                'dsc_tipo_proposta_emprestimo': operacao.get('dsc_tipo_proposta_emprestimo'),
                'dsc_situacao_emprestimo': operacao.get('dsc_situacao_emprestimo'),
                'id': operacao.get('id'),
                'nic_ctr_usuario': operacao.get('nic_ctr_usuario'),
                'nom_cliente': operacao.get('nom_cliente'),
                'num_contrato': operacao.get('num_contrato'),
                'qtd_parcela': operacao.get('qtd_parcela'),
                'val_liquido': operacao.get('val_liquido'),
                'val_emissao': operacao.get('val_emissao'),
                
                # Campos novos do operation (API 2)
                'dat_credito': operation_data.get('dat_credito'),
                'link_cmp_pgmt': operation_data.get('link_cmp_pgmt'),
                'has_insurance': operation_data.get('has_insurance'),
                'val_seguro': operation_data.get('val_seguro'),
                'marital_status': operation_data.get('marital_status'),
                'related_party_key': operation_data.get('related_party_key'),
                'first_installment_value': operation_data.get('first_installment_value'),
                'first_installment_date': operation_data.get('first_installment_date'),
                'process_id': operation_data.get('process_id'),
                'unico_score': operation_data.get('unico_score'),
                'serpro_score': operation_data.get('serpro_score'),
                'credit_type': operation_data.get('credit_type'),
                'assistance_type': operation_data.get('assistance_type'),
                'balance_request_info': operation_data.get('balance_request_info'),
                'benefit_state': operation_data.get('benefit_state'),
                'legal_representative': operation_data.get('legal_representative'),
                'created_at': operation_data.get('created_at'),
                'modified_at': operation_data.get('modified_at'),
                'policy_number': operation_data.get('policy_number'),
                'in100': operation_data.get('in100'),
                'purchaser': operation_data.get('purchaser'),
                'op_stage_id': operation_data.get('op_stage_id'),
                'requester_identifier_key': operation_data.get('requester_identifier_key'),
                'bank_name': operation_data.get('bank_name'),
                
                # üìú CAMPOS DO HIST√ìRICO (funcionando!)
                'historico_id': hist.get('id'),
                'historico_debt_key': hist.get('debt_key'),
                'historico_credit_operation_key': hist.get('credit_operation_key'),
                'historico_status': hist.get('status'),
                'historico_description': hist.get('description'),
                'historico_event_datetime': hist.get('event_datetime'),
                
                'quantidade_historicos': len(histories)
            }
            
            registros.append(registro)
        
        return registros


class GerenciadorBanco:
    """Gerencia opera√ß√µes com banco de dados"""
    
    def __init__(self, config: Config):
        self.config = config
        self.engine = None
        
        if config.USAR_BANCO:
            try:
                self.engine = create_engine(config.DB_CONNECTION_STRING)
                print("‚úÖ Conex√£o com banco estabelecida")
            except Exception as e:
                print(f"‚ùå Erro ao conectar no banco: {e}")
    
    def limpar_tabela(self):
        """Limpa dados da tabela antes de inserir"""
        if not self.engine:
            return
        
        try:
            with self.engine.connect() as conn:
                conn.execute(text(f"DELETE FROM {self.config.TABELA_DESTINO}"))
                conn.commit()
            print(f"üóëÔ∏è  Tabela {self.config.TABELA_DESTINO} limpa com sucesso")
        except Exception as e:
            print(f"‚ùå Erro ao limpar tabela: {e}")
    
    def inserir_dados(self, df: pd.DataFrame):
        """Insere dados no banco"""
        if not self.engine or df.empty:
            return
        
        try:
            df.to_sql(
                self.config.TABELA_DESTINO,
                self.engine,
                if_exists='append',
                index=False
            )
            print(f"‚úÖ {len(df)} registros inseridos na tabela {self.config.TABELA_DESTINO}")
        except Exception as e:
            print(f"‚ùå Erro ao inserir dados: {e}")


# ============================================================================
# FLUXO PRINCIPAL
# ============================================================================

def executar_extracao():
    """FLUXO DE EXECU√á√ÉO PRINCIPAL"""
    
    print("="*80)
    print("INICIANDO EXTRA√á√ÉO DE DADOS - API FINTECH (VERS√ÉO CORRIGIDA)")
    print("="*80)
    print()
    
    config = Config()
    
    if config.MOSTRAR_CONFIG_INICIAL:
        print("üìã CONFIGURA√á√ïES ATIVAS:")
        
        # Mostra o modo de per√≠odo ativo
        if config.USAR_DIA_ESPECIFICO:
            print(f"   üìÖ Modo: Dia Espec√≠fico ‚Üí {config.DIA_ESPECIFICO}")
        elif config.USAR_PERIODO_CUSTOMIZADO:
            print(f"   üìÜ Modo: Per√≠odo Customizado ‚Üí {config.PERIODO_INICIO} at√© {config.PERIODO_FIM}")
        elif config.USAR_ULTIMOS_DIAS:
            print(f"   üïê Modo: √öltimos {config.QUANTIDADE_ULTIMOS_DIAS} Dias")
        elif config.USAR_MES_COMPLETO:
            print(f"   üìä Modo: M√™s Completo ‚Üí {config.MES_COMPLETO}")
        else:
            print(f"   üóìÔ∏è  Modo: Per√≠odo Geral ‚Üí desde {config.DATA_INICIO_GERAL}")
        
        # Filtros adicionais ativos
        filtros_ativos = []
        if config.FILTRAR_POR_MES and not config.USAR_MES_COMPLETO:
            filtros_ativos.append(f"M√™s: {config.MES_ANO_DESEJADO}")
        if config.FILTRAR_POR_LOTE:
            filtros_ativos.append(f"Lote: {config.LOTE_DESEJADO}")
        if config.FILTRAR_POR_STATUS:
            filtros_ativos.append(f"Status: {', '.join(config.STATUS_DESEJADOS)}")
        if config.FILTRAR_POR_CPF:
            filtros_ativos.append(f"CPFs: {len(config.CPFS_PERMITIDOS)} permitidos")
        if config.FILTRAR_POR_VALOR_MINIMO:
            filtros_ativos.append(f"Valor m√≠n: R$ {config.VALOR_MINIMO:,.2f}")
        
        if filtros_ativos:
            print(f"   üîç Filtros ativos: {' | '.join(filtros_ativos)}")
        
        print(f"   ‚öôÔ∏è  Ordem: {config.ORDEM_DATAS} | Dias/per√≠odo: {config.DIAS_POR_PERIODO}")
        print(f"   üíæ Banco: {'ATIVO' if config.USAR_BANCO else 'INATIVO'} | Excel: {'SIM' if config.EXPORTAR_EXCEL else 'N√ÉO'}")
        print()
    
    # Inicializa componentes
    api = FintechAPI(config)
    processador = ProcessadorDados()
    banco = GerenciadorBanco(config)
    
    # ETAPA 1: Autentica
    if not api.autenticar():
        print("‚ùå Falha na autentica√ß√£o. Abortando.")
        return
    
    # ETAPA 2: Gera per√≠odos
    print("üìÖ Gerando per√≠odos de consulta...")
    df_periodos = processador.gerar_periodos(config)
    print(f"   ‚úì {len(df_periodos)} per√≠odos gerados\n")
    
    if df_periodos.empty:
        print("‚ö†Ô∏è  Nenhum per√≠odo encontrado com os filtros aplicados")
        return
    
    # ETAPA 3: Processa cada per√≠odo
    todos_registros = []
    total_operacoes = 0
    tempo_inicio = time.time()
    erros_detalhados = []  # Lista para guardar erros
    
    print("üîÑ Processando dados...\n")
    
    for idx, periodo in df_periodos.iterrows():
        print(f"üìÜ [{idx+1}/{len(df_periodos)}] Per√≠odo: {periodo['data_inicio']} at√© {periodo['data_fim']} (Lote {periodo['lote']})")
        
        # API 1: Consulta lista de opera√ß√µes
        print("   üîç Consultando lista de opera√ß√µes...")
        operacoes = api.consultar_operacoes(periodo['data_inicio'], periodo['data_fim'])
        
        if not operacoes:
            print("   ‚ö†Ô∏è  Nenhuma opera√ß√£o encontrada\n")
            continue
        
        operacoes_validas = [op for op in operacoes if op.get('cpf')]
        total_operacoes += len(operacoes)
        
        # Aplica limite se configurado
        if config.LIMITE_OPERACOES:
            operacoes_validas = operacoes_validas[:config.LIMITE_OPERACOES]
            print(f"   ‚ö†Ô∏è  Limitado a {config.LIMITE_OPERACOES} opera√ß√µes (config)")
        
        print(f"   ‚úì {len(operacoes_validas)} opera√ß√µes encontradas")
        print(f"   üì• Consultando detalhes individuais (API 2)...\n")
        
        sucesso = 0
        com_historico = 0
        sem_historico = 0
        erros = 0
        erros_mostrados = 0  # Contador de erros j√° mostrados
        
        # API 2: Consulta detalhes de cada opera√ß√£o
        if config.MOSTRAR_PROGRESSO_BARRA:
            # Desativa o debug de hist√≥ricos quando a barra est√° ativa (evita poluir a tela)
            debug_original = config.DEBUG_HISTORICOS
            config.DEBUG_HISTORICOS = False
            
            pbar = tqdm(
                operacoes_validas, 
                desc="      Consultando", 
                unit=" ops",
                ncols=100,
                colour='green',
                bar_format='{l_bar}{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}]'
            )
            
            for op in pbar:
                try:
                    detalhes, erro = api.consultar_detalhes_operacao(
                        op.get('debt_key'),
                        op.get('credit_operation_key')
                    )
                    
                    if detalhes:
                        sucesso += 1
                        registros = processador.processar_operacao_com_historicos(op, detalhes, config)
                        
                        if registros:
                            com_historico += 1
                            todos_registros.extend(registros)
                        else:
                            sem_historico += 1
                    else:
                        erros += 1
                        # Guarda informa√ß√µes do erro
                        erros_detalhados.append({
                            'debt_key': op.get('debt_key'),
                            'cpf': op.get('cpf'),
                            'nom_cliente': op.get('nom_cliente'),
                            'num_contrato': op.get('num_contrato'),
                            'erro': erro or 'Erro desconhecido'
                        })
                        
                        # Mostra detalhes dos primeiros erros para diagn√≥stico
                        if erros_mostrados < config.DEBUG_PRIMEIROS_ERROS:
                            print(f"\n      üîç Debug Erro #{erros}:")
                            print(f"         Contrato: {op.get('num_contrato')}")
                            print(f"         Debt Key: {op.get('debt_key')}")
                            print(f"         Credit Op Key: {op.get('credit_operation_key')}")
                            print(f"         Erro: {erro}")
                            erros_mostrados += 1
                            if erros_mostrados == config.DEBUG_PRIMEIROS_ERROS:
                                print(f"\n      ‚ÑπÔ∏è  Pr√≥ximos erros ser√£o omitidos (total at√© agora: {erros})\n")
                    
                    # Atualiza descri√ß√£o com contadores claros
                    pbar.set_description(
                        f"      ‚úì {com_historico} com hist | ‚ö† {sem_historico} sem hist | ‚úó {erros} erros"
                    )
                    
                except Exception as e:
                    erros += 1
                    erros_detalhados.append({
                        'debt_key': op.get('debt_key'),
                        'cpf': op.get('cpf'),
                        'nom_cliente': op.get('nom_cliente'),
                        'num_contrato': op.get('num_contrato'),
                        'erro': f'Exce√ß√£o: {str(e)}'
                    })
                    
                    # Mostra exce√ß√µes cr√≠ticas
                    if erros_mostrados < config.DEBUG_PRIMEIROS_ERROS:
                        print(f"\n      ‚ö†Ô∏è  EXCE√á√ÉO #{erros}: {str(e)}")
                        erros_mostrados += 1
                    
                    pbar.set_description(
                        f"      ‚úì {com_historico} com hist | ‚ö† {sem_historico} sem hist | ‚úó {erros} erros"
                    )
                
                time.sleep(config.DELAY_ENTRE_REQUESTS)
            
            # Restaura debug original
            config.DEBUG_HISTORICOS = debug_original
        
        print(f"\n   üìä Resultados: {sucesso} OK | {com_historico} com hist√≥rico | {sem_historico} sem hist√≥rico | {erros} erros\n")
    
    tempo_total = time.time() - tempo_inicio
    
    # RESUMO FINAL
    print("="*80)
    print("üìä RESUMO DA EXTRA√á√ÉO")
    print("="*80)
    print(f"   ‚è±Ô∏è  Tempo total: {tempo_total:.1f}s ({tempo_total/60:.1f} min)")
    print(f"   üìã Opera√ß√µes consultadas: {total_operacoes}")
    print(f"   üìù Registros gerados: {len(todos_registros)}")
    
    # Mostra resumo de erros se houver
    if erros_detalhados:
        print(f"   ‚ö†Ô∏è  Total de erros: {len(erros_detalhados)}")
        
        # Agrupa erros por tipo
        tipos_erro = {}
        for erro_info in erros_detalhados:
            tipo = erro_info['erro'].split(':')[0] if ':' in erro_info['erro'] else erro_info['erro']
            tipos_erro[tipo] = tipos_erro.get(tipo, 0) + 1
        
        print(f"\n   üîç Tipos de erro:")
        for tipo, count in sorted(tipos_erro.items(), key=lambda x: x[1], reverse=True):
            print(f"      ‚Ä¢ {tipo}: {count} ocorr√™ncias")
    
    print()
    
    if not todos_registros:
        print("‚ö†Ô∏è  Nenhum registro com hist√≥rico encontrado")
        return
    
    df_final = pd.DataFrame(todos_registros)
    
    # Aplica filtros adicionais nos dados
    if config.FILTRAR_POR_STATUS or config.FILTRAR_POR_CPF or config.FILTRAR_POR_VALOR_MINIMO:
        print("\nüîç Aplicando filtros nos dados...")
        df_final = processador.aplicar_filtros_dados(df_final, config)
        print()
    
    # Exibe amostragem
    print("="*80)
    print("üîç AMOSTRAGEM DOS DADOS")
    print("="*80)
    print(f"   Total de linhas: {len(df_final)}")
    print()
    
    if 'historico_status' in df_final.columns:
        print("üè∑Ô∏è  TOP 5 STATUS:")
        for status, count in df_final['historico_status'].value_counts().head(5).items():
            print(f"   ‚Ä¢ {status}: {count}")
        print()
    
    # Gera relat√≥rio estat√≠stico
    processador.gerar_relatorio_estatistico(df_final, config)
    
    # Lista erros detalhados se configurado
    if config.LISTAR_ERROS_DETALHADOS and erros_detalhados:
        print("="*80)
        print("‚ö†Ô∏è  DETALHAMENTO DE ERROS")
        print("="*80)
        print(f"   Total de opera√ß√µes com erro: {len(erros_detalhados)}\n")
        
        # Mostra primeiros 20 erros
        for i, erro_info in enumerate(erros_detalhados[:20], 1):
            print(f"   {i}. Contrato: {erro_info.get('num_contrato', 'N/A')}")
            print(f"      Cliente: {erro_info.get('nom_cliente', 'N/A')}")
            print(f"      CPF: {erro_info.get('cpf', 'N/A')}")
            print(f"      Erro: {erro_info['erro']}")
            print()
        
        if len(erros_detalhados) > 20:
            print(f"   ... e mais {len(erros_detalhados) - 20} erros")
        print()
    
    # Salva log de erros se configurado
    if config.SALVAR_LOG_ERROS and erros_detalhados:
        try:
            import os
            os.makedirs(config.CAMINHO_LOG_ERROS, exist_ok=True)
            
            log_filename = f"{config.CAMINHO_LOG_ERROS}erros_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            
            with open(log_filename, 'w', encoding='utf-8') as f:
                f.write("="*80 + "\n")
                f.write("LOG DE ERROS - EXTRA√á√ÉO API FINTECH\n")
                f.write("="*80 + "\n\n")
                f.write(f"Data/Hora: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n")
                f.write(f"Total de erros: {len(erros_detalhados)}\n\n")
                
                for i, erro_info in enumerate(erros_detalhados, 1):
                    f.write(f"{i}. Contrato: {erro_info.get('num_contrato', 'N/A')}\n")
                    f.write(f"   Cliente: {erro_info.get('nom_cliente', 'N/A')}\n")
                    f.write(f"   CPF: {erro_info.get('cpf', 'N/A')}\n")
                    f.write(f"   Debt Key: {erro_info.get('debt_key', 'N/A')}\n")
                    f.write(f"   Erro: {erro_info['erro']}\n\n")
            
            print(f"üìÑ Log de erros salvo: {log_filename}\n")
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao salvar log: {e}\n")
    
    # Exporta Excel
    if config.EXPORTAR_EXCEL:
        try:
            import os
            os.makedirs(config.CAMINHO_EXCEL, exist_ok=True)
            
            # Nome do arquivo
            if config.NOME_ARQUIVO_CUSTOMIZADO:
                nome_arquivo = config.NOME_ARQUIVO_CUSTOMIZADO
            elif config.USAR_DIA_ESPECIFICO:
                data = datetime.strptime(config.DIA_ESPECIFICO, "%Y-%m-%d")
                nome_arquivo = f"Fintech_{data.strftime('%d-%m-%Y')}.xlsx"
            elif 'created_at' in df_final.columns and df_final['created_at'].notna().any():
                primeiro_created_at = df_final['created_at'].dropna().iloc[0]
                data_ref = datetime.fromisoformat(primeiro_created_at.replace('Z', '+00:00'))
                mes_nome = ['Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho',
                           'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'][data_ref.month - 1]
                ano_curto = data_ref.strftime('%y')
                nome_arquivo = f"Fintech_{mes_nome}{ano_curto}.xlsx"
            else:
                nome_arquivo = f"Fintech_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
            
            caminho_completo = config.CAMINHO_EXCEL + nome_arquivo
            df_final.to_excel(caminho_completo, index=False)
            print(f"üìÅ Excel exportado: {caminho_completo}")
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao exportar Excel: {e}")
    
    # Insere no banco
    if config.USAR_BANCO:
        print()
        if config.LIMPAR_TABELA_ANTES:
            banco.limpar_tabela()
        banco.inserir_dados(df_final)
    
    print()
    print("‚úÖ Processo finalizado!")
    print("="*80)


if __name__ == "__main__":
    executar_extracao()
