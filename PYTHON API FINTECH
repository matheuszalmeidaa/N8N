import requests
import pandas as pd
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import time
from sqlalchemy import create_engine, text
from tqdm import tqdm
import warnings
from cassandra.cluster import Cluster
from cassandra.auth import PlainTextAuthProvider
from cassandra.query import BatchStatement, SimpleStatement

warnings.filterwarnings('ignore')

# CONFIGURA√á√ÉO
class Config:
    """Configura√ß√µes principais do sistema"""

    # === AUTENTICA√á√ÉO API ===
    API_BASE_URL = "https://api.anossafintech.com.br"
    CPF_LOGIN = "05134108560"
    PROMOT_ID = "1"
    PASSWORD = "Alcif@2026"

    # === MODO DE CONSULTA ===
    # TESTE, DIA_ESPECIFICO, MES_ESPECIFICO, ANO_COMPLETO, PERIODO_PERSONALIZADO
    MODO_CONSULTA = "PERIODO_PERSONALIZADO"

    # TESTE: um dia s√≥
    DATA_TESTE = "2025-11-27"

    # DIA_ESPECIFICO
    DIA_ESPECIFICO = "2025-11-27"

    # MES_ESPECIFICO (MM/YYYY)
    MES_ESPECIFICO = "11/2025"

    # ANO_COMPLETO
    ANO_COMPLETO = 2025

    # PERIODO_PERSONALIZADO
    DATA_INICIO_PERSONALIZADA = "2025-03-18"
    DATA_FIM_PERSONALIZADA = "2025-03-18"

    # === CONFIGURA√á√ÉO DE LOTES / DATAS ===
    DIAS_POR_PERIODO = 1        # tamanho do intervalo
    PERIODOS_POR_LOTE = 5       # quantos per√≠odos formam 1 lote
    ORDEM_DATAS = "decrescente" # "crescente" ou "decrescente"

    # FILTRO DE LOTE (opcional)
    LOTE_DESEJADO = None  # ex: 1 para s√≥ o primeiro lote, ou None para todos

    # === DELAYS E PERFORMANCE ===
    DELAY_ENTRE_REQUESTS = 0.2
    TIMEOUT_REQUEST = 90
    MOSTRAR_PROGRESSO_BARRA = False

    # === BANCO DE DADOS POSTGRESQL ===
    USAR_BANCO = False
    DB_CONNECTION_STRING = "postgresql://usuario:senha@localhost:5432/database"
    TABELA_DESTINO = "fintech_operacoes_mensal"
    LIMPAR_TABELA_ANTES = True

    # === CASSANDRA ===
    USAR_CASSANDRA = True
    CASSANDRA_HOST = "localhost"
    CASSANDRA_KEYSPACE = "fintech"
    CASSANDRA_TABELA = "fintech_operacoes_mensal"
    CASSANDRA_TAMANHO_PACOTE = 1000
    CASSANDRA_USERNAME = None  # Opcional
    CASSANDRA_PASSWORD = None  # Opcional
    LIMPAR_CASSANDRA_ANTES = False

    # === EXPORTA√á√ÉO ===
    EXPORTAR_EXCEL = True
    CAMINHO_EXCEL = "./"
    CAMINHO_CSV_SAIDA = "/root/Debitos/fintech_operacoes_mensal.csv"

    # === LOGS ===
    MOSTRAR_CONFIG_INICIAL = True
    MOSTRAR_LOGS_DETALHADOS = False


# ============================================================================
# FUN√á√ÉO AUXILIAR: HIST√ìRICOS
# ============================================================================

def extrair_histories(detalhes: dict):

    operation = detalhes.get("operation", {}) or {}

    histories = []
    if isinstance(operation.get("histories"), list):
        histories = operation["histories"]
    elif isinstance(detalhes.get("histories"), list):
        histories = detalhes["histories"]

    return operation, histories


# ============================================================================
# CLASSES PRINCIPAIS
# ============================================================================

class FintechAPI:
    """Gerenciador de chamadas √† API"""

    def __init__(self, config: Config):
        self.config = config
        self.token = None
        self.session = requests.Session()

    def autenticar(self) -> bool:
        url = f"{self.config.API_BASE_URL}/auth/login"
        payload = {
            "cpf": self.config.CPF_LOGIN,
            "promot_id": self.config.PROMOT_ID,
            "password": self.config.PASSWORD
        }
        headers = {"Content-Type": "application/json"}
        try:
            response = self.session.post(url, json=payload, headers=headers)
            response.raise_for_status()
            data = response.json()

            self.token = (
                data.get('token')
                or data.get('access_token')
                or data.get('auth_token')
                or data.get('bearer_token')
            )
            if not self.token and 'data' in data:
                self.token = data['data'].get('token')
            if not self.token and 'result' in data:
                self.token = data['result'].get('token')

            if self.token:
                self.session.headers.update({'Authorization': f'Bearer {self.token}'})
                print("‚úÖ Autentica√ß√£o realizada com sucesso!")
                try:
                    print(f" Token: {self.token[:20]}...{self.token[-10:]}\n")
                except:
                    pass
                return True
            else:
                print("‚ùå Token n√£o encontrado na resposta")
                return False
        except requests.exceptions.HTTPError as e:
            print(f"‚ùå Erro HTTP na autentica√ß√£o: {e}")
            print(f" Status code: {response.status_code}")
            return False
        except Exception as e:
            print(f"‚ùå Erro na autentica√ß√£o: {e}")
            return False

    def consultar_operacoes(self, data_inicio: str, data_fim: str) -> Optional[List[Dict]]:
        url = f"{self.config.API_BASE_URL}/inss/v1/operation"
        params = {
            'data_inicio': data_inicio,
            'data_fim': data_fim,
            'por_pagina': 200000
        }
        try:
            response = self.session.get(url, params=params, timeout=self.config.TIMEOUT_REQUEST)
            response.raise_for_status()
            data = response.json()
            operacoes = data.get('operacoes', []) or data.get('operations', [])
            return operacoes
        except Exception as e:
            print(f" ‚ùå Erro ao consultar opera√ß√µes: {e}")
            return None

    def consultar_detalhes_operacao(self, debt_key: str, credit_operation_key: str = None) -> Optional[Dict]:
        url = f"{self.config.API_BASE_URL}/inss/v1/operation/{debt_key}"
        if credit_operation_key and str(credit_operation_key).strip():
            url += f"?credit_operation_key={credit_operation_key}"
        try:
            response = self.session.get(url, timeout=self.config.TIMEOUT_REQUEST)
            response.raise_for_status()
            return response.json()
        except Exception:
            return None


class ProcessadorDados:
    """Processa e transforma os dados extra√≠dos"""

    @staticmethod
    def gerar_periodos(config: Config) -> pd.DataFrame:
        if config.MODO_CONSULTA == "TESTE":
            data_inicio = datetime.strptime(config.DATA_TESTE, "%Y-%m-%d")
            data_fim = data_inicio
        elif config.MODO_CONSULTA == "DIA_ESPECIFICO":
            data_inicio = datetime.strptime(config.DIA_ESPECIFICO, "%Y-%m-%d")
            data_fim = data_inicio
        elif config.MODO_CONSULTA == "MES_ESPECIFICO":
            mes, ano = config.MES_ESPECIFICO.split('/')
            data_inicio = datetime(int(ano), int(mes), 1)
            if int(mes) == 12:
                data_fim = datetime(int(ano), 12, 31)
            else:
                data_fim = datetime(int(ano), int(mes) + 1, 1) - timedelta(days=1)
        elif config.MODO_CONSULTA == "ANO_COMPLETO":
            data_inicio = datetime(config.ANO_COMPLETO, 1, 1)
            data_fim = datetime(config.ANO_COMPLETO, 12, 31)
        elif config.MODO_CONSULTA == "PERIODO_PERSONALIZADO":
            data_inicio = datetime.strptime(config.DATA_INICIO_PERSONALIZADA, "%Y-%m-%d")
            data_fim = datetime.strptime(config.DATA_FIM_PERSONALIZADA, "%Y-%m-%d")
        else:
            raise ValueError(f"MODO_CONSULTA inv√°lido: {config.MODO_CONSULTA}")

        periodos = []
        cursor = data_inicio
        indice = 1

        while cursor <= data_fim:
            inicio_intervalo = cursor
            fim_intervalo = cursor + timedelta(days=config.DIAS_POR_PERIODO - 1)
            if fim_intervalo > data_fim:
                fim_intervalo = data_fim

            mes_ano = inicio_intervalo.strftime("%m/%Y")
            periodos.append({
                'indice': indice,
                'data_inicio': inicio_intervalo.strftime("%Y-%m-%d"),
                'data_fim': fim_intervalo.strftime("%Y-%m-%d"),
                'mes_ano': mes_ano
            })

            cursor += timedelta(days=config.DIAS_POR_PERIODO)
            indice += 1

        df = pd.DataFrame(periodos)

        if config.ORDEM_DATAS == "decrescente":
            df = df.iloc[::-1].reset_index(drop=True)
            df['indice'] = range(1, len(df) + 1)

        df['lote'] = ((df.index) // config.PERIODOS_POR_LOTE) + 1

        if config.LOTE_DESEJADO:
            df = df[df['lote'] == config.LOTE_DESEJADO].reset_index(drop=True)

        return df

    @staticmethod
    def formatar_data_completa(data_raw) -> str:
        if not data_raw:
            return None
        try:
            d = datetime.fromisoformat(data_raw.replace('Z', '+00:00'))
            return d.strftime("%d/%m/%Y %H:%M:%S")
        except:
            return None

    @staticmethod
    def processar_operacao_com_historicos(operacao: Dict, detalhes: Dict) -> List[Dict]:
        operation_data, histories = extrair_histories(detalhes)

        if not histories:
            return []

        data_formatada = ProcessadorDados.formatar_data_completa(
            operacao.get('dat_emprestimo')
        )

        registros = []
        for hist in histories:
            registro = {
                'cpf': operacao.get('cpf') or operation_data.get('cpf'),
                'dat_emprestimo_completo': data_formatada,
                'debt_key': operacao.get('debt_key') or operation_data.get('debt_key'),
                'credit_operation_key': operacao.get('credit_operation_key') or operation_data.get('credit_operation_key'),
                'dsc_tipo_proposta_emprestimo': operacao.get('dsc_tipo_proposta_emprestimo') or operation_data.get('dsc_tipo_proposta_emprestimo'),
                'dsc_situacao_emprestimo': operacao.get('dsc_situacao_emprestimo') or operation_data.get('dsc_situacao_emprestimo'),
                'id': operacao.get('id') or operation_data.get('id'),
                'nic_ctr_usuario': operacao.get('nic_ctr_usuario') or operation_data.get('nic_ctr_usuario'),
                'nom_cliente': operacao.get('nom_cliente') or operation_data.get('nom_cliente'),
                'num_contrato': operacao.get('num_contrato') or operation_data.get('num_contrato'),
                'qtd_parcela': operacao.get('qtd_parcela') or operation_data.get('qtd_parcela'),
                'val_liquido': operacao.get('val_liquido') or operation_data.get('val_liquido'),
                'val_emissao': operacao.get('val_emissao') or operation_data.get('val_emissao'),

                'dat_credito': operation_data.get('dat_credito'),
                'link_cmp_pgmt': operation_data.get('link_cmp_pgmt'),
                'has_insurance': operation_data.get('has_insurance'),
                'val_seguro': operation_data.get('val_seguro'),
                'marital_status': operation_data.get('marital_status'),
                'related_party_key': operation_data.get('related_party_key'),
                'first_installment_value': operation_data.get('first_installment_value'),
                'first_installment_date': operation_data.get('first_installment_date'),
                'process_id': operation_data.get('process_id'),
                'unico_score': operation_data.get('unico_score'),
                'serpro_score': operation_data.get('serpro_score'),
                'credit_type': operation_data.get('credit_type'),
                'assistance_type': operation_data.get('assistance_type'),
                'balance_request_info': operation_data.get('balance_request_info'),
                'benefit_state': operation_data.get('benefit_state'),
                'legal_representative': operation_data.get('legal_representative'),
                'created_at': operation_data.get('created_at'),
                'modified_at': operation_data.get('modified_at'),
                'policy_number': operation_data.get('policy_number'),
                'in100': operation_data.get('in100'),
                'purchaser': operation_data.get('purchaser'),
                'op_stage_id': operation_data.get('op_stage_id'),
                'requester_identifier_key': operation_data.get('requester_identifier_key'),
                'bank_name': operation_data.get('bank_name'),

                'historico_id': hist.get('id'),
                'historico_debt_key': hist.get('debt_key'),
                'historico_credit_operation_key': hist.get('credit_operation_key'),
                'historico_status': hist.get('status'),
                'historico_description': hist.get('description'),
                'historico_event_datetime': hist.get('event_datetime'),
                ##'quantidade_historicos': len(histories),
            }
            registros.append(registro)

        return registros


class GerenciadorBanco:
    """Gerencia opera√ß√µes com banco de dados PostgreSQL"""

    def __init__(self, config: Config):
        self.config = config
        self.engine = None
        if config.USAR_BANCO:
            try:
                self.engine = create_engine(config.DB_CONNECTION_STRING)
                print("‚úÖ Conex√£o com banco PostgreSQL estabelecida")
            except Exception as e:
                print(f"‚ùå Erro ao conectar no banco PostgreSQL: {e}")

    def limpar_tabela(self):
        if not self.engine:
            return
        try:
            with self.engine.connect() as conn:
                conn.execute(text(f"DELETE FROM {self.config.TABELA_DESTINO}"))
                conn.commit()
                print(f"üóëÔ∏è Tabela {self.config.TABELA_DESTINO} limpa com sucesso")
        except Exception as e:
            print(f"‚ùå Erro ao limpar tabela: {e}")

    def inserir_dados(self, df: pd.DataFrame):
        if not self.engine or df.empty:
            return
        try:
            df.to_sql(self.config.TABELA_DESTINO, self.engine, if_exists='append', index=False)
            print(f"‚úÖ {len(df)} registros inseridos na tabela {self.config.TABELA_DESTINO}")
        except Exception as e:
            print(f"‚ùå Erro ao inserir dados: {e}")


class GerenciadorCassandra:
    """Gerencia opera√ß√µes com banco de dados Cassandra"""

    def __init__(self, config: Config):
        self.config = config
        self.cluster = None
        self.session = None
        
        if config.USAR_CASSANDRA:
            try:
                if config.CASSANDRA_USERNAME and config.CASSANDRA_PASSWORD:
                    auth_provider = PlainTextAuthProvider(
                        username=config.CASSANDRA_USERNAME,
                        password=config.CASSANDRA_PASSWORD
                    )
                    self.cluster = Cluster([config.CASSANDRA_HOST], auth_provider=auth_provider)
                else:
                    self.cluster = Cluster([config.CASSANDRA_HOST])
                
                self.session = self.cluster.connect()
                self.session.set_keyspace(config.CASSANDRA_KEYSPACE)
                print(f"‚úÖ Conex√£o com Cassandra estabelecida (keyspace: {config.CASSANDRA_KEYSPACE})")
            except Exception as e:
                print(f"‚ùå Erro ao conectar no Cassandra: {e}")
                self.session = None

    def limpar_tabela(self):
        """Limpa todos os dados da tabela Cassandra"""
        if not self.session:
            return
        try:
            query = f"TRUNCATE {self.config.CASSANDRA_TABELA}"
            self.session.execute(query)
            print(f"üóëÔ∏è Tabela {self.config.CASSANDRA_TABELA} limpa com sucesso no Cassandra")
        except Exception as e:
            print(f"‚ùå Erro ao limpar tabela Cassandra: {e}")

    def inserir_dados(self, df: pd.DataFrame):
        """Insere dados no Cassandra em lotes"""
        if not self.session or df.empty:
            return
        
        try:
            # Prepara a query de inser√ß√£o
            colunas = df.columns.tolist()
            placeholders = ', '.join(['?' for _ in colunas])
            colunas_str = ', '.join(colunas)
            query = f"INSERT INTO {self.config.CASSANDRA_TABELA} ({colunas_str}) VALUES ({placeholders})"
            prepared = self.session.prepare(query)
            
            total_registros = len(df)
            registros_inseridos = 0
            
            print(f"üì§ Inserindo {total_registros} registros no Cassandra em lotes de {self.config.CASSANDRA_TAMANHO_PACOTE}...")
            
            # Processa em lotes
            for i in range(0, total_registros, self.config.CASSANDRA_TAMANHO_PACOTE):
                batch = BatchStatement()
                lote_df = df.iloc[i:i + self.config.CASSANDRA_TAMANHO_PACOTE]
                
                for _, row in lote_df.iterrows():
                    # Converte valores None e NaN para None adequadamente
                    valores = []
                    for val in row.values:
                        if pd.isna(val):
                            valores.append(None)
                        else:
                            valores.append(val)
                    batch.add(prepared, valores)
                
                self.session.execute(batch)
                registros_inseridos += len(lote_df)
                
                if registros_inseridos % (self.config.CASSANDRA_TAMANHO_PACOTE * 5) == 0:
                    print(f" ... {registros_inseridos}/{total_registros} registros inseridos")
            
            print(f"‚úÖ {registros_inseridos} registros inseridos no Cassandra (tabela: {self.config.CASSANDRA_TABELA})")
            
        except Exception as e:
            print(f"‚ùå Erro ao inserir dados no Cassandra: {e}")

    def fechar_conexao(self):
        """Fecha a conex√£o com Cassandra"""
        if self.cluster:
            self.cluster.shutdown()
            print("üîå Conex√£o com Cassandra encerrada")


# ============================================================================
# FLUXO PRINCIPAL
# ============================================================================

def executar_extracao():
    print("="*80)
    print("INICIANDO EXTRA√á√ÉO DE DADOS - API FINTECH")
    print("="*80)
    print()

    config = Config()

    print("‚öôÔ∏è MODO DE OPERA√á√ÉO ATIVO:")
    if config.MODO_CONSULTA == "TESTE":
        print(f" üß™ TESTE - Consultando apenas o dia {config.DATA_TESTE}")
        print(" (Modo r√°pido para validar se o sistema est√° funcionando)")
    elif config.MODO_CONSULTA == "DIA_ESPECIFICO":
        print(f" üìÖ DIA ESPEC√çFICO - {config.DIA_ESPECIFICO}")
    elif config.MODO_CONSULTA == "MES_ESPECIFICO":
        print(f" üìÜ M√äS ESPEC√çFICO - {config.MES_ESPECIFICO}")
    elif config.MODO_CONSULTA == "ANO_COMPLETO":
        print(f" üìä ANO COMPLETO - {config.ANO_COMPLETO}")
    elif config.MODO_CONSULTA == "PERIODO_PERSONALIZADO":
        print(f" üéØ PER√çODO PERSONALIZADO - {config.DATA_INICIO_PERSONALIZADA} at√© {config.DATA_FIM_PERSONALIZADA}")

    print(f" üì§ Exportar Excel/CSV: {'SIM' if config.EXPORTAR_EXCEL else 'N√ÉO'}")
    print(f" üíæ Salvar no PostgreSQL: {'SIM' if config.USAR_BANCO else 'N√ÉO'}")
    print(f" üóÑÔ∏è Salvar no Cassandra: {'SIM' if config.USAR_CASSANDRA else 'N√ÉO'}")
    print()

    api = FintechAPI(config)
    processador = ProcessadorDados()
    banco = GerenciadorBanco(config)
    cassandra = GerenciadorCassandra(config)

    if not api.autenticar():
        print("‚ùå Falha na autentica√ß√£o. Abortando.")
        return

    # Limpa tabelas se configurado
    if config.USAR_BANCO and config.LIMPAR_TABELA_ANTES:
        banco.limpar_tabela()
    
    if config.USAR_CASSANDRA and config.LIMPAR_CASSANDRA_ANTES:
        cassandra.limpar_tabela()

    print("üìÖ Gerando per√≠odos de consulta...")
    df_periodos = processador.gerar_periodos(config)
    print(f" ‚úì {len(df_periodos)} per√≠odos gerados\n")

    if df_periodos.empty:
        print("‚ö†Ô∏è Nenhum per√≠odo encontrado com os filtros aplicados")
        return

    todos_registros = []
    total_operacoes = 0
    tempo_inicio = time.time()
    print("üîÑ Processando dados...\n")

    for idx, periodo in df_periodos.iterrows():
        print(f"üìÜ [{idx+1}/{len(df_periodos)}] {periodo['data_inicio']} at√© {periodo['data_fim']} (Lote {periodo['lote']})")

        operacoes = api.consultar_operacoes(periodo['data_inicio'], periodo['data_fim'])
        if not operacoes:
            print(" ‚ö†Ô∏è Nenhuma opera√ß√£o encontrada\n")
            continue

        operacoes_validas = [op for op in operacoes if op.get('cpf')]
        total_operacoes += len(operacoes)
        print(f" ‚úì {len(operacoes_validas)} opera√ß√µes v√°lidas encontradas")

        sucesso = 0
        com_historico = 0
        sem_historico = 0
        erros = 0

        if config.MOSTRAR_PROGRESSO_BARRA:
            pbar = tqdm(operacoes_validas,
                        desc=" üì• Detalhes",
                        unit="op",
                        ncols=100,
                        colour='cyan',
                        bar_format='{desc}: {percentage:3.0f}%|{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}]')
            for op in pbar:
                try:
                    detalhes = api.consultar_detalhes_operacao(
                        op.get('debt_key'),
                        op.get('credit_operation_key')
                    )
                    if detalhes:
                        sucesso += 1
                        registros = processador.processar_operacao_com_historicos(op, detalhes)
                        if registros:
                            com_historico += 1
                            todos_registros.extend(registros)
                        else:
                            sem_historico += 1
                    else:
                        erros += 1
                    pbar.set_postfix_str(f"‚úì{com_historico} hist | ‚óã{sem_historico} s/hist | ‚úó{erros} err")
                except Exception:
                    erros += 1
                time.sleep(config.DELAY_ENTRE_REQUESTS)
        else:
            print(f" üì• Consultando detalhes de {len(operacoes_validas)} opera√ß√µes...")
            for i, op in enumerate(operacoes_validas, 1):
                if i % 50 == 0:
                    print(f" ... {i}/{len(operacoes_validas)} (‚úì{com_historico} com hist | ‚óã{sem_historico} sem hist)")
                try:
                    detalhes = api.consultar_detalhes_operacao(
                        op.get('debt_key'),
                        op.get('credit_operation_key')
                    )
                    if detalhes:
                        sucesso += 1
                        registros = processador.processar_operacao_com_historicos(op, detalhes)
                        if registros:
                            com_historico += 1
                            todos_registros.extend(registros)
                        else:
                            sem_historico += 1
                    else:
                        erros += 1
                except Exception:
                    erros += 1
                time.sleep(config.DELAY_ENTRE_REQUESTS)

        print(f" üìä ‚úì {com_historico} com hist√≥rico | ‚óã {sem_historico} sem hist√≥rico | ‚úó {erros} erros")
        print()

    tempo_total = time.time() - tempo_inicio

    print("="*80)
    print("üìä RESUMO DA EXTRA√á√ÉO")
    print("="*80)
    print(f" ‚è±Ô∏è Tempo total: {tempo_total:.1f} segundos ({tempo_total/60:.1f} minutos)")
    print(f" üìã Total de opera√ß√µes consultadas (API 1): {total_operacoes}")
    print(f" üìù Total de registros gerados (com hist√≥ricos): {len(todos_registros)}")
    print()

    if not todos_registros:
        print("‚ö†Ô∏è Nenhum registro com hist√≥rico encontrado")
        cassandra.fechar_conexao()
        return

    df_final = pd.DataFrame(todos_registros)

    # Exporta CSV
    if config.EXPORTAR_EXCEL:
        # CSV padr√£o
        caminho_padrao = f"{config.CAMINHO_EXCEL}/fintech_extracao.csv"
        df_final.to_csv(caminho_padrao, index=False, sep=";", encoding="utf-8-sig")
        print(f"üìÅ Arquivo CSV padr√£o gerado: {caminho_padrao}")
        
        # CSV de sa√≠da customizado
        if config.CAMINHO_CSV_SAIDA:
            df_final.to_csv(config.CAMINHO_CSV_SAIDA, index=False, sep=";", encoding="utf-8-sig")
            print(f"üìÅ Arquivo CSV de sa√≠da gerado: {config.CAMINHO_CSV_SAIDA}")

    # Salva no PostgreSQL
    if config.USAR_BANCO:
        banco.inserir_dados(df_final)

    # Salva no Cassandra
    if config.USAR_CASSANDRA:
        cassandra.inserir_dados(df_final)

    # Fecha conex√£o Cassandra
    cassandra.fechar_conexao()

    print("\n‚úÖ Processo finalizado com sucesso!")

if __name__ == "__main__":
    executar_extracao()
